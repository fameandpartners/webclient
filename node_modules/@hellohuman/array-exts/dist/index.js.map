{"version":3,"sources":["array-utils.ts","set-utils.ts","index.ts"],"names":[],"mappings":";AAuNC,aAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,wDAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAAA,IAAA,IAAA,EAAA,EAAA,EAAA,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,QAAA,EAAA,KAAA,EAAA,QAAA,GAAA,EAAA,SAAA,GAAA,GAAA,IAAA,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,mDAAA,SAAA,EAAA,GAAA,GAAA,OAAA,YAAA,OAAA,IAAA,uBAAA,OAAA,UAAA,SAAA,KAAA,GAAA,OAAA,MAAA,KAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,CAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,EAAA,QAAA,EAAA,EAAA,OAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,GAvND,IAAM,EAA2B,OAAO,oBAAoB,MAAM,WAE7D,EAAyB,SAAS,YACnC,OAAO,eAAe,MAAM,UAAW,UAAW,CAC9C,MAAY,SAAA,GAAgB,IAAA,EAAA,KAChB,OAAA,KAAa,OAAO,SAAC,EAAS,GAC3B,OAAA,EAAG,OAAO,EAAE,KAAK,EAAM,KAC/B,KAEP,YAAY,IAIf,EAAyB,SAAS,iBACnC,OAAO,eAAe,MAAM,UAAW,eAAgB,CACnD,MAAS,SAAA,GACC,IAAA,EAAO,IAAI,IAAI,MACf,EAAO,IAAI,IAAI,GACV,OAAA,EAAA,IAAI,IAAI,EAAI,GAAM,OAAO,SAAA,GAAK,OAAA,EAAK,IAAI,UAKzD,EAAyB,SAAS,gBACnC,OAAO,eAAe,MAAM,UAAW,cAAe,CAClD,MAAK,WACO,OAAA,KACH,OACA,OACG,SAAC,EAAG,EAAG,GACH,OAAA,EAAE,QAAQ,KAAO,EAAI,GAAK,EAAE,QAAQ,KAAO,EAAI,OAMlE,EAAyB,SAAS,oBACnC,OAAO,eAAe,MAAM,UAAW,kBAAmB,CACtD,MAAS,SAAA,EAAa,GACZ,IAAA,EAAiB,GAqDhB,OAnDO,KAAA,QAAQ,SAAC,EAAG,GAClB,IAAA,EAAM,GACN,EAAW,EAAE,GAEb,GAAA,EAAS,CAcL,GAbA,EAAQ,mBACR,EAAG,OAAA,OAAA,GAAS,IACD,GAGX,EAAQ,gBACR,OAAO,QAAQ,GAAG,IAAI,SAAW,GAAA,IAAA,EAAA,EAAA,EAAA,GAAT,EAAS,EAAA,GAAN,EAAM,EAAA,GACzB,EAAQ,eAAgB,SAAS,KACjC,EAAI,GAAK,KAKjB,EAAQ,aAAc,CAClB,KAAE,EAAQ,gBAAgB,GACpB,MAAA,IAAI,MAEF,mCAAA,OAAA,EAAQ,aAFhB,kCAMJ,EAAM,EAAE,EAAQ,cAShB,GANA,EAAQ,iBACF,KAAO,GAAO,EAAE,KAClB,EAAW,EAAQ,iBAIvB,EAAQ,cAAe,CACnB,GAAoB,iBAAb,EAGD,MAAA,IAAI,MACiB,uBAAA,OAAA,EAAQ,MAAA,OAAA,EADnC,2BAFA,EAAW,EAAS,oBAQ5B,EAAM,EAGV,EAAe,GAAY,GAAK,IAG7B,KAKd,EAAyB,SAAS,cACnC,OAAO,eAAe,MAAM,UAAW,YAAa,CAChD,MAAK,WAGG,GAFQ,KAEJ,KAAK,SAAA,GAAK,MAAa,WAAb,EAAO,KAAiB,CAChC,IAAA,EAAc,GAUb,OAbC,KAIJ,QAAQ,SAAA,GAIS,IAFb,EAAO,OACH,SAAA,GAAK,OAAA,KAAK,UAAU,KAAO,KAAK,UAAU,KAC5C,QAEF,EAAO,KAAK,KAGb,EAGA,OAAA,EAAA,IAAI,IAhBH,UAqBnB,EAAyB,SAAS,eACnC,OAAO,eAAe,MAAM,UAAW,aAAc,CACjD,MAAS,SAAA,GAGD,GAAqB,WAArB,EAFQ,KACU,OAAS,GADnB,KAC4B,IACL,CAEzB,IAAA,EAAO,IAAI,IAJT,KAIiB,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,MAC3C,EAAO,IAAI,IACZ,EAAc,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,MAGrC,EAAa,IAAI,IAAI,EAAI,GAAM,OAAO,SAAA,GAAK,OAAC,EAAK,IAAI,MACpD,OAAA,EAAI,GAAY,IAAI,SAAA,GAAK,OAAA,KAAK,MAAM,KAErC,IAAA,EAAO,IAAI,IAZT,MAaF,EAAO,IAAI,IAAI,GAEV,OAAA,EAAA,IAAI,IAAI,EAAI,GAAM,OAAO,SAAA,GAAK,OAAC,EAAK,IAAI,UAM9D,EAAyB,SAAS,kBACnC,OAAO,eAAe,MAAM,UAAW,gBAAiB,CACpD,MAAS,SAAA,GACC,IAAA,EAAM,KAER,GAAqB,WAArB,EADc,EAAI,OAAS,GAAK,EAAI,IACL,CACzB,IAAA,EAAI,EAAI,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,KAChC,EAAK,EAAc,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,KAM1C,MAHA,GAAA,OAAA,EAAA,EAAE,OAAO,SAAA,GAAK,OAAC,EAAE,SAAS,KAAI,IAAI,SAAA,GAAK,OAAA,KAAK,MAAM,MAClD,EAAA,EAAE,OAAO,SAAA,GAAK,OAAC,EAAE,SAAS,KAAI,IAAI,SAAA,GAAK,OAAA,KAAK,MAAM,OAQlD,MAHA,GAAA,OAAA,EAAA,EAAI,OAAO,SAAA,GAAK,OAAC,EAAM,SAAS,MAChC,EAAA,EAAM,OAAO,SAAA,GAAK,OAAC,EAAI,SAAS,UAQlD,EAAyB,SAAS,uBACnC,OAAO,eAAe,MAAM,UAAW,qBAAsB,CACzD,MAAK,WACO,OAAA,KAAa,OAAO,SAAA,GAAK,QAAE,KAEvC,YAAY,IAIf,EAAyB,SAAS,UACnC,OAAO,eAAe,MAAM,UAAW,QAAS,CAC5C,MAAK,WACO,OAAA,KAAa,MAAM,EAAG,GAAG,MAKxC,EAAyB,SAAS,aACnC,OAAO,eAAe,MAAM,UAAW,WAAY,CAC/C,MAAS,SAAA,EAAoB,GACrB,OAAA,EACQ,KAAa,OAAO,GAGzB,QAKd,EAAyB,SAAS,YACnC,OAAO,eAAe,MAAM,UAAW,UAAW,CAC9C,MAAY,SAAA,GACF,IAAA,EAAM,IAAI,IAUT,OATO,KAAA,QAAQ,SAAA,GACZ,IAAA,EAAM,EAAU,GAChB,EAAa,EAAI,IAAI,GACtB,EAGD,EAAW,KAAK,GAFhB,EAAI,IAAI,EAAK,CAAC,MAKf;;ACtIlB,aAAA,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,mDAAA,SAAA,EAAA,GAAA,GAAA,OAAA,YAAA,OAAA,IAAA,uBAAA,OAAA,UAAA,SAAA,KAAA,GAAA,OAAA,MAAA,KAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,CAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,EAAA,QAAA,EAAA,EAAA,OAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,GAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GA9ED,IAAM,EAAyB,OAAO,oBAAoB,IAAI,WAEzD,EAAuB,SAAS,eACjC,OAAO,eAAe,IAAI,UAAW,aAAc,CAC/C,MAAS,SAAA,GAGD,GAAqB,WAArB,EAFc,KAAK,KAAO,GAAK,KAAK,SAAS,OAAO,OAErB,CACzB,IAAA,EAAa,IAAI,IACnB,EAAI,MAAM,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,MAO/B,OALU,IAAI,IACjB,EAAI,GAAO,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,MAG9B,QAAQ,SAAA,GAAK,OAAA,EAAW,OAAO,KACjC,IAAI,IAAI,EAAI,GAAY,IAAI,SAAA,GAAK,OAAA,KAAK,MAAM,MAE7C,IAAA,EAAa,IAAI,IAAI,MAEpB,OADP,EAAM,QAAQ,SAAA,GAAK,OAAA,EAAW,OAAO,KAC9B,KAMlB,EAAuB,SAAS,kBACjC,OAAO,eAAe,IAAI,UAAW,gBAAiB,CAClD,MAAS,SAAA,GAGD,GAAqB,WAArB,EAFc,KAAK,KAAO,GAAK,KAAK,SAAS,OAAO,OAErB,CACzB,IAAA,EAAa,IAAI,IACnB,EAAI,MAAM,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,MAc/B,OAZU,IAAI,IACjB,EAAI,GAAO,IAAI,SAAA,GAAK,OAAA,KAAK,UAAU,MAG9B,QAAQ,SAAA,GACR,EAAW,IAAI,GAGhB,EAAW,OAAO,GAFlB,EAAW,IAAI,KAMhB,IAAI,IAAI,EAAI,GAAY,IAAI,SAAA,GAAK,OAAA,KAAK,MAAM,MAE7C,IAAA,EAAa,IAAI,IAAI,MASpB,OARP,EAAM,QAAQ,SAAA,GACL,EAAW,IAAI,GAGhB,EAAW,OAAO,GAFlB,EAAW,IAAI,KAMhB,KAMlB,EAAuB,SAAS,iBACjC,OAAO,eAAe,IAAI,UAAW,eAAgB,CACjD,MAAS,SAAA,GAAa,IAAA,EAAA,KACZ,EAAe,IAAI,IAQlB,OANP,EAAM,QAAQ,SAAA,GACN,EAAK,IAAI,IACT,EAAa,IAAI,KAIlB;;AC1EnB,aADA,QAAA,iBACA,QAAA","file":"index.js","sourceRoot":"../lib","sourcesContent":["const currentPropertiesInArray = Object.getOwnPropertyNames(Array.prototype);\n\nif (!currentPropertiesInArray.includes('flatMap')) {\n    Object.defineProperty(Array.prototype, 'flatMap', {\n        value<T, E>(f: (t: T) => E[]) {\n            return (this as T[]).reduce((ys: E[], x: T) => {\n                return ys.concat(f.call(this, x));\n            }, []);\n        },\n        enumerable: false\n    });\n}\n\nif (!currentPropertiesInArray.includes('intersection')) {\n    Object.defineProperty(Array.prototype, 'intersection', {\n        value<T>(other: T[]) {\n            const aSet = new Set(this as T[]);\n            const bSet = new Set(other as T[]);\n            return [...new Set([...aSet].filter(x => bSet.has(x)))];\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('duplication')) {\n    Object.defineProperty(Array.prototype, 'duplication', {\n        value<T>() {\n            return (this as T[])\n                .sort()\n                .filter(\n                    (e, p, a) =>\n                        a.indexOf(e) === p - 1 || a.indexOf(e) === p + 1\n                );\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('flattenToObject')) {\n    Object.defineProperty(Array.prototype, 'flattenToObject', {\n        value<T>(key: string, options?: ArrayFlattenConfig) {\n            const flattenedArray = {};\n\n            (this as T[]).forEach((a, i) => {\n                let val = {};\n                let savedKey = a[key];\n\n                if (options) {\n                    if (options.excludeKey) {\n                        val = { ...(a as any) };\n                        delete val[key];\n                    }\n\n                    if (options.includedFields) {\n                        Object.entries(a).map(([k, v]) => {\n                            if (options.includedFields!.includes(k)) {\n                                val[k] = v;\n                            }\n                        });\n                    }\n\n                    if (options.fieldAsValue) {\n                        if (!(options.fieldAsValue in a)) {\n                            throw new Error(\n                                `Unable to flatten this array as ${\n                                    options.fieldAsValue\n                                } does not exist in the object`\n                            );\n                        }\n                        val = a[options.fieldAsValue];\n                    }\n\n                    if (options.keyIfNotExists) {\n                        if (!(key in a) || !a[key]) {\n                            savedKey = options.keyIfNotExists;\n                        }\n                    }\n\n                    if (options.keyValToLower) {\n                        if (typeof savedKey === 'string') {\n                            savedKey = savedKey.toLowerCase();\n                        } else {\n                            throw new Error(\n                                `Unable to lowercase ${key}: ${savedKey} as it is not a string`\n                            );\n                        }\n                    }\n                } else {\n                    val = a;\n                }\n\n                flattenedArray[savedKey || i] = val;\n            });\n\n            return flattenedArray;\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('uniqueMap')) {\n    Object.defineProperty(Array.prototype, 'uniqueMap', {\n        value<T>() {\n            const arr = this as T[];\n            // If anything in the array is an object, we need to do more unique matching since Set's still treat them as unique\n            if (arr.some(v => typeof v === 'object')) {\n                const output: T[] = [];\n                arr.forEach(v => {\n                    if (\n                        output.filter(\n                            x => JSON.stringify(x) === JSON.stringify(v)\n                        ).length === 0\n                    ) {\n                        output.push(v);\n                    }\n                });\n                return output;\n            }\n\n            return [...new Set(arr)];\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('difference')) {\n    Object.defineProperty(Array.prototype, 'difference', {\n        value<T>(other: T[]) {\n            const arr = this as T[];\n            const firstItem = arr.length > 0 && arr[0];\n            if (typeof firstItem === 'object') {\n                // Convert all elements to a JSON string then set them for difference\n                const aSet = new Set(arr.map(x => JSON.stringify(x)));\n                const bSet = new Set(\n                    (other as T[]).map(x => JSON.stringify(x))\n                );\n\n                const difference = new Set([...aSet].filter(x => !bSet.has(x)));\n                return [...difference].map(x => JSON.parse(x));\n            } else {\n                const aSet = new Set(arr);\n                const bSet = new Set(other as T[]);\n\n                return [...new Set([...aSet].filter(x => !bSet.has(x)))];\n            }\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('allDifference')) {\n    Object.defineProperty(Array.prototype, 'allDifference', {\n        value<T>(other: T[]) {\n            const arr = this as T[];\n            const firstItem = arr.length > 0 && arr[0];\n            if (typeof firstItem === 'object') {\n                const a = arr.map(x => JSON.stringify(x));\n                const b = (other as T[]).map(x => JSON.stringify(x));\n\n                const difference = [\n                    ...a.filter(x => !b.includes(x)).map(x => JSON.parse(x)),\n                    ...b.filter(x => !a.includes(x)).map(x => JSON.parse(x))\n                ];\n                return difference;\n            } else {\n                const difference = [\n                    ...arr.filter(x => !other.includes(x)),\n                    ...other.filter(x => !arr.includes(x))\n                ];\n                return difference;\n            }\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('notNullOrUndefined')) {\n    Object.defineProperty(Array.prototype, 'notNullOrUndefined', {\n        value<T>() {\n            return (this as T[]).filter(x => !!x);\n        },\n        enumerable: false\n    });\n}\n\nif (!currentPropertiesInArray.includes('first')) {\n    Object.defineProperty(Array.prototype, 'first', {\n        value<T>() {\n            return (this as T[]).slice(0, 1)[0];\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('filterIf')) {\n    Object.defineProperty(Array.prototype, 'filterIf', {\n        value<T>(condition: boolean, fn: (arg?: any) => boolean) {\n            if (condition) {\n                return (this as T[]).filter(fn);\n            }\n\n            return this as T[];\n        }\n    });\n}\n\nif (!currentPropertiesInArray.includes('groupBy')) {\n    Object.defineProperty(Array.prototype, 'groupBy', {\n        value<T, K>(keyGetter: (item: T) => K) {\n            const map = new Map<K, T[]>();\n            (this as T[]).forEach(item => {\n                const key = keyGetter(item);\n                const collection = map.get(key);\n                if (!collection) {\n                    map.set(key, [item]);\n                } else {\n                    collection.push(item);\n                }\n            });\n            return map;\n        }\n    });\n}\n","const currentPropertiesInSet = Object.getOwnPropertyNames(Set.prototype);\n\nif (!currentPropertiesInSet.includes('difference')) {\n    Object.defineProperty(Set.prototype, 'difference', {\n        value<T>(other: Set<T>) {\n            const firstItem = this.size > 0 && this.values().next().value;\n\n            if (typeof firstItem === 'object') {\n                const difference = new Set(\n                    [...this].map(x => JSON.stringify(x))\n                );\n                const otherSet = new Set(\n                    [...other].map(x => JSON.stringify(x))\n                );\n\n                otherSet.forEach(o => difference.delete(o));\n                return new Set([...difference].map(x => JSON.parse(x)));\n            } else {\n                const difference = new Set(this);\n                other.forEach(o => difference.delete(o));\n                return difference;\n            }\n        }\n    });\n}\n\nif (!currentPropertiesInSet.includes('allDifference')) {\n    Object.defineProperty(Set.prototype, 'allDifference', {\n        value<T>(other: Set<T>) {\n            const firstItem = this.size > 0 && this.values().next().value;\n\n            if (typeof firstItem === 'object') {\n                const difference = new Set(\n                    [...this].map(x => JSON.stringify(x))\n                );\n                const otherSet = new Set(\n                    [...other].map(x => JSON.stringify(x))\n                );\n\n                otherSet.forEach(o => {\n                    if (!difference.has(o)) {\n                        difference.add(o);\n                    } else {\n                        difference.delete(o);\n                    }\n                });\n\n                return new Set([...difference].map(x => JSON.parse(x)));\n            } else {\n                const difference = new Set(this);\n                other.forEach(o => {\n                    if (!difference.has(o)) {\n                        difference.add(o);\n                    } else {\n                        difference.delete(o);\n                    }\n                });\n\n                return difference;\n            }\n        }\n    });\n}\n\nif (!currentPropertiesInSet.includes('intersection')) {\n    Object.defineProperty(Set.prototype, 'intersection', {\n        value<T>(other: Set<T>) {\n            const intersection = new Set<T>();\n\n            other.forEach(o => {\n                if (this.has(o)) {\n                    intersection.add(o);\n                }\n            });\n\n            return intersection;\n        }\n    });\n}\n","import './array-utils';\nimport './set-utils';\n"]}